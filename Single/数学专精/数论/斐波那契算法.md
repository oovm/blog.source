---
title: 斐波那契算法
author: Aster
type: post
date: 2016-01-15T10:37:31+00:00
url: /2016/01/fibonacci_arithmetic/
featured_image: /wp-content/uploads/2016/01/Apple_Loge-e1483879815648-100x56.jpg
duoshuo_thread_id:
  - "6373465143430349569"
categories:
  - CODE➤GEASS
tags:
  - Haskell
  - 斐波那契
  - 算法

---
我们来讨论下斐波那契数列的算法.所谓斐波那契数列就是那些前两项为0,1或者1,1,后一项为前两项之和的数列.

我这里沿用Mathematica上的定义,a1=a2=1给出代码

唉,有人说斐波那契数列不是能解出解析式的吗,那不就有O(1)算法了吗,还研究啥呢.

$$f(n) = \frac{1}{{\sqrt 5 }}\left[ {{{\left( {\frac{1}{2}\left( {\sqrt 5  + 1} \right)} \right)}^n} - {{\left( {\frac{2}{{\sqrt 5  + 1}}} \right)}^n}\cos \left( {\pi n} \right)} \right]$$

编程啊不是数学,浮点数对于纯整数运算来说是没必要的,而且为了防止因浮点数产生的误差反而会加大运算量,得不偿失.

<!--more-->

根据定义,我们可以给出递归算法

$$\left\{ {\begin{array}{*{20}{l}}  
{f(1) = f(2) = 1}\\  
{f(n) = f(n - 1) + f(n - 2)}  
\end{array}} \right.$$

<pre class="height-set:false lang:haskell decode:true">--该算法能轻易的爆掉你可爱的内存
slowestFibonacci :: Integer -> Integer
slowestFibonacci 1 = 1
slowestFibonacci 2 = 1
slowestFibonacci n = slowestFibonacci (n-1) + slowestFibonacci (n-2)</pre>

换用命令式的思维思考事实上要求第n个斐波那契数只要两个位置不断更新即可,如果硬要求整个表的话也只要去最后两个数运算在插入表中

<pre class="height-set:false lang:haskell decode:true">fibonacciStep :: Num t => (t, t) -> (t, t)
fibonacciPair :: (Eq a, Num a, Num t) => a -> (t, t)
fibonacciStep (u,v) = (v,u+v)
fibonacciPair 1 = ( 1, 1)
fibonacciPair n = fibonacciStep (fibonacciPair (n-1))
fibonaccin n = fst ( fibonacciPair n)

--这就叫所谓的尾递归,大多数循环都能转化成尾递归
canonicalFibonacci :: [Integer]
canonicalFibonacci = 1:1:zipWith (+) canonicalFibonacci (tail canonicalFibonacci)

fibonacci :: [Integer]
fibonacci = scanl (+) 1 (1:fibonacci)</pre>

O(n)的算法在n>10^6的情况下也不能用了,我们需要更好的算法.

二阶线性递推数列可以写成矩阵表达式,转而求矩阵幂

$$\left[ {\begin{array}{*{20}{l}}  
{{f_n}}\\  
{{f_{n - 1}}}  
\end{array}} \right] = \left( {\begin{array}{*{20}{c}}  
1&1\\  
1&0  
\end{array}} \right)\left[ {\begin{array}{*{20}{l}}  
{{f_{n - 1}}}\\  
{{f_{n - 2}}}  
\end{array}} \right] = {\left( {\begin{array}{*{20}{c}}  
1&1\\  
1&0  
\end{array}} \right)^2}\left[ {\begin{array}{*{20}{l}}  
{{f_{n - 2}}}\\  
{{f_{n - 3}}}  
\end{array}} \right] = ... = {\left( {\begin{array}{*{20}{c}}  
1&1\\  
1&0  
\end{array}} \right)^n}\left[ {\begin{array}{*{20}{l}}  
1\\  
1  
\end{array}} \right]$$

于是可以使用矩阵快速幂算法求出值,当然一般大到这个程度都是要取模的,所以我写了个对任意二阶线性递推数列成立的矩阵幂取模算法

<pre class="height-set:false lang:haskell decode:true">--输入取模
--输入转移矩阵
--输入初始值
--得到数列第n项mod m的结果
modulo = 100000
transMatrix = [[1,1],[1,0]]
firstValue =[[0],[1]]
answer n = head ( head ( multMatrix (fastMatrix transMatrix n modulo) firstValue))

--定义二阶矩阵运算
multMatrix :: Num t => [[t]] -> [[t]] -> [[t]]
multMatrix [[a,b],[c,d]] [[e],[f]] = [[a*e+b*f],[c*e+d*f]]
multMatrix [[a,b],[c,d]] [[e,f],[g,h]] = [[a*e+b*g,a*f+b*h],[c*e+d*g,c*f+d*h]]
modMatrix [[a,b],[c,d]] m = [[mod a m,mod b m],[mod c m,mod d m]]
--快速矩阵幂取模
fastMatrix [[a,b],[c,d]] 0 m = [[1,0],[0,1]]
fastMatrix [[a,b],[c,d]] 1 m = modMatrix [[a,b],[c,d]] m
fastMatrix [[a,b],[c,d]] p m
  | odd p      = modMatrix (multMatrix [[a,b],[c,d]] bak) m
  | otherwise  = bak
  where 
    foo = p `div` 2
    bar = modMatrix [[a^2+b*c,a*b+b*d],[a*c+c*d,b*c+d^2]] m
    bak = fastMatrix bar foo m</pre>

当然单纯求斐波那契数列的话可以将上述方法特异化(化简),还可以使用递推公式,这可不是上面只能推一项的爆内存公式,一次性可以折半算.

$$\left\{ {\begin{array}{*{20}{l}}  
{{f\_{2n}} = {f\_{n + 1}}^2 - {f_{n - 1}}^2}\\  
{{f\_{2n - 1}} = {f\_n}[{f\_{n + 1}} + {f\_{n - 1}}]}  
\end{array}} \right.$$

<pre class="height-set:false lang:haskell decode:true">--斐波那契第n个对m求模
fibm :: (Integral b, Integral a) => a -> b -> b
fibm n m = fst ( fibs n m)
fibs n m
  |n == 0 = (0,1)
  |mod n 2 == 1 = (p,q)
  |otherwise = (r,p)
  where
    (a,b) = fibs (div n 2) m
    p = mod (b*b+a*a) m
    q = mod (b*(2*a+b)) m
    r = mod (a*(2*b-a)) m
--急速斐波那契算法
fastestFibonacci :: Int -> Integer
fastestFibonacci n = snd . foldl' fib (1, 0) . dropWhile not ( [testBit n k | k <- let s = finiteBitSize n in [s-1,s-2..0]])
    where
        fib (f, g) p
            | p         = (f*(f+2*g), ss)
            | otherwise = (ss, g*(2*f-g))
            where ss = f*f+g*g</pre>

关于斐波那契的性质那是相当的多,甚至很多只要学过点微积分,线性代数,组合数学皮毛就能看出来的结论能写一本又一本书,记得美国有本期刊就刊斐波那契,到现在刊了五十多年了.我当然也掉进过这个坑,我先慢慢整理下笔记.

---

题图为苹果Logo的斐波那契设计.
