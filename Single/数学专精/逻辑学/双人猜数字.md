


孙膑，庞涓都是鬼谷子的徒弟。一天鬼谷子出了这道题目：
他从2到99中选出两个不同的整数，把积告诉孙，把和告诉庞；
庞说：我虽然不能确定这两个数是什么，但是我肯定你也不知道这两个数是什么。
孙说：我本来的确不知道，但是听你这么一说，我现在能够确定这两个数字了。
庞说：既然你这么说，我现在也知道这两个数字是什么了。
请问这两个数字是什么？为什么？


假设两个数之和s=a+b，两个数之积p=ab

第一句“甲对乙说，虽然我不知道这两个数是什么，但是我知道你一定不知道。”

如果a、b都是素数，那么根据因式分解，乙可以从p得到a、b的取值。

“甲确定乙一定不知道”说明s不能表示为两个素数之和。根据哥德巴赫猜想（对小于200的偶数根据枚举法成立），每一个不小于6的偶数可以表示为两个素数之和。所以有“s为奇数且s-2不是素数”。

进而有推论“a,b中有一个奇数一个偶数”和“p为偶数且p/2不是素数”想接着写下去，但发现没有什么很好的思路了。

根据已有的结论对s=非素数奇数+2进行枚举，貌似a=4,b=13,s=17,p=52是一组解。


```wl
cond = {1 < x < 100, 1 < y < 100, x < y, x + y < 100};
plus[xy_] := Select[step1, Plus @@ xy == Plus @@ #&]
times[xy_] := Select[step1, Times @@ xy == Times @@ #&]

step1 = {x, y} /. Solve[cond, {x, y}, Integers];
step2 = Select[step1, AllTrue[plus[#], Length@times[#] != 1&]&]
step3 = Select[step2, Length@Intersection[times[#], step2] == 1&]
step4 = Select[step3, Length@Intersection[plus[#], step3] == 1&]
```

不明原因慢的离谱

```scala
type XY = (Int, Int)
val step1 = for {
  x <- 1 to 100
  y <- 1 to 100
  if 1 < x && x < y && x + y < 100
} yield (x, y)
def plus(a: XY) = step1 filter {(b: XY) => b._1 + b._2 == a._1 + a._2}
def times(a: XY) = step1 filter {(b: XY) => b._1 * b._2 == a._1 * a._2}
val step2 = step1 filter {plus(_) forall {times(_).size != 1}}
val step3 = step2 filter {times(_).intersect(step2).size == 1}
val step4 = step3 filter {plus(_).intersect(step3).size == 1}
```

因此不得不用记忆化的方式优化解法:

```wl
pools = Join @@ Table[{i, j}, {i, 2, 99}, {j, 2, i}];
mul[{x_, y_}] := x * y
sums = Dispatch@Thread[Tr /@ #[[All, 1]] -> #]&@GatherBy[pools, Tr@#&];
prods = Dispatch@Thread[mul /@ #[[All, 1]] -> #]&@GatherBy[pools, mul];
pDontKnow[p_] := pDontKnow[p] = Length[p /. prods] != 1
sDontKnow[s_] := sDontKnow[s] = Length[s /. sums] != 1
sKnowPdontKnow[s_] := sKnowPdontKnow[s] = And @@ (pDontKnow /@ mul /@ (s /. sums))
pNowKnow[p_] := pNowKnow[p] = Length@Select[p /. prods, sKnowPdontKnow[Tr@#]&] == 1
sKnowPnowKnow[s_] := sKnowPnowKnow[s] = Length@Select[s /. sums, pNowKnow[mul@#]&] == 1

Select[pools, pDontKnow[mul@#] && sDontKnow[Tr@#] && sKnowPdontKnow[Tr@#] && pNowKnow[mul@#] && sKnowPnowKnow[Tr@#]&]
```


https://puzzling.stackexchange.com/questions/2780/generalization-of-sum-and-product-puzzle

https://www.math.uni-bielefeld.de/~sillke/PUZZLES/logic_sum_product